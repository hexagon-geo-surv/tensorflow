diff --git a/third_party/nvidia/lib/TritonNVIDIAGPUToLLVM/ElementwiseOpToLLVM.cpp b/third_party/nvidia/lib/TritonNVIDIAGPUToLLVM/ElementwiseOpToLLVM.cpp
--- a/third_party/nvidia/lib/TritonNVIDIAGPUToLLVM/ElementwiseOpToLLVM.cpp
+++ b/third_party/nvidia/lib/TritonNVIDIAGPUToLLVM/ElementwiseOpToLLVM.cpp
@@ -27,15 +27,20 @@ struct Fp8ConversionDesc {
 static const Fp8ConversionDesc Fp16_to_Fp8E5M2_RTNE(bool hasNativeFP) {
   Fp8ConversionDesc ret;
   if (!hasNativeFP) {
-    ret = {"{                            \n"
-           ".reg .b32 a<2>;              \n"
-           "and.b32 a0, $1, 0xfffefffe;  \n"   // a0 &= 0xfffefffe
-           "and.b32 a1, $2, 0xfffefffe;  \n"   // (strip lowest bit)
-           "add.u32 a0, a0, 0x00800080;  \n"   // a0 += 0x00800080
-           "add.u32 a1, a1, 0x00800080;  \n"   // (round to nearest)
-           "prmt.b32 $0, a0, a1, 0x7531; \n\t" // output = a1a0
-           "}",
-           32, 32, 4};
+    ret = {
+        "{                            \n"
+        ".reg .b32 a<2>;              \n"
+        "and.b32 a0, $1, 0x01000100;  \n"    // a0 = $1 & 0x01000100
+        "and.b32 a1, $2, 0x01000100;  \n"    // (least significant result bit)
+        "shr.b32 a0, a0, 8;           \n"    // a0 >>= 8
+        "shr.b32 a1, a1, 8;           \n"    // (shift the lsb)
+        "add.u32 a0, a0, 0x007f007f;  \n"    // a0 += 0x007f007f
+        "add.u32 a1, a1, 0x007f007f;  \n"    // (add rounding base)
+        "add.u32 a0, a0, $1;          \n"    // res = $1 + lsb + 0x7f
+        "add.u32 a1, a1, $2;          \n"    // (round to nearest)
+        "prmt.b32 $0, a0, a1, 0x7531; \n\t"  // output = a1a0
+        "}",
+        32, 32, 4};
   } else {
     ret = {"cvt.rn.satfinite.e5m2x2.f16x2 $0, $1; \n\t", 32, 16, 2};
   }
