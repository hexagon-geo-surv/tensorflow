diff --git a/shardy/dialect/sdy/transforms/propagation/test/basic_propagation.mlir b/shardy/dialect/sdy/transforms/propagation/test/basic_propagation.mlir
index f812145..3332591 100644
--- a/shardy/dialect/sdy/transforms/propagation/test/basic_propagation.mlir
+++ b/shardy/dialect/sdy/transforms/propagation/test/basic_propagation.mlir
@@ -815,38 +815,3 @@ func.func @scalar_block_arg_with_sharding_constraint(
   }) : (tensor<4x1000xi32>, tensor<4x1xi32>, tensor<4xi32>) -> tensor<4x1000xi32>
   return %0 : tensor<4x1000xi32>
 }
-
-// CHECK-LABEL: func @does_propagate_to_empty_mesh(
-// CHECK-SAME:      %arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a"}, {"b"}]>}
-// CHECK-SAME:      %arg1: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", ?}, {"b", ?}]>}
-// CHECK-SAME:  -> (tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", ?}, {"b", ?}]>}) {
-func.func @does_propagate_to_empty_mesh(%arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a"}, {"b"}]>},
-                  %arg1: tensor<8x8xf32>) -> tensor<8x8xf32> {
-  // CHECK: {sdy.sharding = #sdy.sharding_per_value<[<@mesh_a_2_b_2, [{"a", ?}, {"b", ?}]>]>}
-  %0 = stablehlo.add %arg0, %arg1 {sdy.sharding = #sdy.sharding_per_value<[<@empty_mesh, [{?}, {?}]>]>} : tensor<8x8xf32>
-  return %0: tensor<8x8xf32>
-}
-
-// CHECK-LABEL: func @does_not_propagate_to_empty_mesh_with_closed_sharding(
-// CHECK-SAME:      %arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a"}, {"b"}]>}
-// CHECK-SAME:      %arg1: tensor<8x8xf32>)
-// CHECK-SAME:  -> tensor<8x8xf32> {
-func.func @does_not_propagate_to_empty_mesh_with_closed_sharding(%arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a"}, {"b"}]>},
-                  %arg1: tensor<8x8xf32>) -> tensor<8x8xf32> {
-  // CHECK: {sdy.sharding = #sdy.sharding_per_value<[<@empty_mesh, [{}, {}]>]>}
-  %0 = stablehlo.add %arg0, %arg1 {sdy.sharding = #sdy.sharding_per_value<[<@empty_mesh, [{}, {}]>]>} : tensor<8x8xf32>
-  return %0: tensor<8x8xf32>
-}
-
-// CHECK-LABEL: func @propagate_to_empty_mesh_with_partially_open_sharding(
-// CHECK-SAME:      %arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a"}, {"b"}]>}
-// CHECK-SAME:      %arg1: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", ?}, {?}]>}
-// CHECK-SAME:  -> (tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a", ?}, {?}]>}) {
-func.func @propagate_to_empty_mesh_with_partially_open_sharding(%arg0: tensor<8x8xf32> {sdy.sharding = #sdy.sharding<@mesh_a_2_b_2, [{"a"}, {"b"}]>},
-                  %arg1: tensor<8x8xf32>) -> tensor<8x8xf32> {
-  // CHECK: {sdy.sharding = #sdy.sharding_per_value<[<@mesh_a_2_b_2, [{"a", ?}, {}]>]>}
-  %0 = stablehlo.add %arg0, %arg1 {sdy.sharding = #sdy.sharding_per_value<[<@empty_mesh, [{?}, {}]>]>} : tensor<8x8xf32>
-  return %0: tensor<8x8xf32>
-}
-
-
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 3c2196e..468f5a1 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,49 +1,77 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
---- a/clang/lib/Sema/SemaDecl.cpp
-+++ b/clang/lib/Sema/SemaDecl.cpp
-@@ -4755,8 +4755,16 @@
-         return;
-     }
-   } else {
--    Diag(New->getLocation(), diag::warn_cxx_compat_tentative_definition) << New;
--    Diag(Old->getLocation(), diag::note_previous_declaration);
-+    // C++ may not have a tentative definition rule, but it has a different
-+    // rule about what constitutes a definition in the first place. See
-+    // [basic.def]p2 for details, but the basic idea is: if the old declaration
-+    // contains the extern specifier and doesn't have an initializer, it's fine
-+    // in C++.
-+    if (Old->getStorageClass() != SC_Extern || Old->hasInit()) {
-+      Diag(New->getLocation(), diag::warn_cxx_compat_tentative_definition)
-+          << New;
-+      Diag(Old->getLocation(), diag::note_previous_declaration);
-+    }
-   }
+diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Overload.h b/clang/include/clang/Sema/Overload.h
+--- a/clang/include/clang/Sema/Overload.h
++++ b/clang/include/clang/Sema/Overload.h
+@@ -435,7 +435,8 @@
  
-   if (haveIncompatibleLanguageLinkages(Old, New)) {
-diff -ruN --strip-trailing-cr a/clang/test/Sema/warn-tentative-defn-compat.c b/clang/test/Sema/warn-tentative-defn-compat.c
---- a/clang/test/Sema/warn-tentative-defn-compat.c
-+++ b/clang/test/Sema/warn-tentative-defn-compat.c
-@@ -20,4 +20,7 @@
-                cxx-error {{redefinition of 'k'}}
+           // A function pointer type can be resolved to a member function type,
+           // which is still an identity conversion.
+-          if (auto *N = T->getAs<MemberPointerType>())
++          if (auto *N = T->getAs<MemberPointerType>();
++              N && N->isMemberFunctionPointer())
+             T = C.getDecayedType(N->getPointeeType());
+           return T;
+         };
+diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/overload-resolution-deferred-templates.cpp b/clang/test/SemaCXX/overload-resolution-deferred-templates.cpp
+--- a/clang/test/SemaCXX/overload-resolution-deferred-templates.cpp
++++ b/clang/test/SemaCXX/overload-resolution-deferred-templates.cpp
+@@ -251,3 +251,26 @@
+   e.g(&N::f);
+ }
+ }
++
++#if __cplusplus >= 201402
++namespace PointerToMemData {
++struct N {
++  int field;
++};
++template <typename It, typename T>
++struct B {
++  B(It, T);
++  template <typename It2>
++  B(B<It2, T>);
++};
++template <typename T>
++struct C {
++  auto g() { return B<int, T>(0, T{}); }
++};
++void f() {
++  using T = decltype(C<decltype(&N::field)>{}.g());
++}
++
++}
++
++#endif
+diff -ruN --strip-trailing-cr a/llvm/unittests/ProfileData/DataAccessProfTest.cpp b/llvm/unittests/ProfileData/DataAccessProfTest.cpp
+--- a/llvm/unittests/ProfileData/DataAccessProfTest.cpp
++++ b/llvm/unittests/ProfileData/DataAccessProfTest.cpp
+@@ -10,7 +10,6 @@
+ #include "llvm/ProfileData/DataAccessProf.h"
+ #include "llvm/Support/raw_ostream.h"
+ #include "llvm/Testing/Support/SupportHelpers.h"
+-#include "gmock/gmock-more-matchers.h"
+ #include "gmock/gmock.h"
+ #include "gtest/gtest.h"
  
- // Cannot have two declarations with initializers, that is a redefinition in
--// both C and C++.
-+// both C and C++. However, C++ does have a different definition of what makes
-+// a declaration a definition.
-+extern const int a;
-+const int a = 12; // Okay in C and C++
-diff -ruN --strip-trailing-cr a/mlir/lib/TableGen/Pattern.cpp b/mlir/lib/TableGen/Pattern.cpp
---- a/mlir/lib/TableGen/Pattern.cpp
-+++ b/mlir/lib/TableGen/Pattern.cpp
-@@ -304,8 +304,8 @@
-     assert(index < 0);
-     auto *operand = cast<NamedTypeConstraint *>(op->getArg(getArgIndex()));
-     if (operand->isOptional()) {
--      auto repl =
--          formatv(fmt, formatv("({0}.empty() ? Value() : *{0}.begin())", name));
-+      auto repl = formatv(
-+          fmt, formatv("({0}.empty() ? ::mlir::Value() : *{0}.begin())", name));
-       LLVM_DEBUG(dbgs() << repl << " (OptionalOperand)\n");
-       return std::string(repl);
-     }
+diff -ruN --strip-trailing-cr a/mlir/include/mlir/Query/Matcher/SliceMatchers.h b/mlir/include/mlir/Query/Matcher/SliceMatchers.h
+--- a/mlir/include/mlir/Query/Matcher/SliceMatchers.h
++++ b/mlir/include/mlir/Query/Matcher/SliceMatchers.h
+@@ -14,6 +14,7 @@
+ #define MLIR_TOOLS_MLIRQUERY_MATCHERS_SLICEMATCHERS_H
+ 
+ #include "mlir/Analysis/SliceAnalysis.h"
++#include "mlir/IR/Operation.h"
+ 
+ /// A matcher encapsulating `getBackwardSlice` method from SliceAnalysis.h.
+ /// Additionally, it limits the slice computation to a certain depth level using
+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+--- a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
++++ b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+@@ -12874,6 +12874,7 @@
+     ),
+     includes = ["include"],
+     deps = [
++        ":Analysis",
+         ":FuncDialect",
+         ":IR",
+         ":Reducer",
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index d345d6f..856245e 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "52ed6791f87a3ef862f555f84ba88a7cdf8fe461"
-    LLVM_SHA256 = "5f4230b06dd2ff977919f26e2deb0b82da00f0a3265f60ac206743169693e933"
+    LLVM_COMMIT = "c41812e6eaa95a7e43e0613d9ffab6f5eb17b92c"
+    LLVM_SHA256 = "db6323b5b8a95cfcafe214864f8eb36279940b2b4753b1182dfd138f623ef194"
 
     tf_http_archive(
         name = name,
diff --git a/third_party/stablehlo/temporary.patch b/third_party/stablehlo/temporary.patch
index a37aeb2..f5c6a00 100755
--- a/third_party/stablehlo/temporary.patch
+++ b/third_party/stablehlo/temporary.patch
@@ -61,4 +61,16 @@ diff --ruN a/stablehlo/stablehlo/dialect/StablehloOps.td b/stablehlo/stablehlo/d
      ]> {
    let summary = "Recv operation";
    let description = [{
+diff --ruN a/stablehlo/stablehlo/tests/transforms/stablehlo_convert_to_signless.mlir b/stablehlo/stablehlo/tests/transforms/stablehlo_convert_to_signless.mlir
+--- stablehlo/stablehlo/tests/transforms/stablehlo_convert_to_signless.mlir
++++ stablehlo/stablehlo/tests/transforms/stablehlo_convert_to_signless.mlir
+@@ -9,7 +9,7 @@
+   %3 = builtin.unrealized_conversion_cast %2 : memref<i16> to memref<ui16>
+   %4 = bufferization.to_tensor %3 : memref<ui16> to tensor<ui16>
+   %5 = builtin.unrealized_conversion_cast %4 : tensor<ui16> to tensor<i16>
+-  %6 = bufferization.to_memref %5 : tensor<i16> to memref<i16>
++  %6 = bufferization.to_buffer %5 : tensor<i16> to memref<i16>
+   %7 = builtin.unrealized_conversion_cast %6 : memref<i16> to memref<ui16>
+   func.return %7 : memref<ui16>
+ }
 
